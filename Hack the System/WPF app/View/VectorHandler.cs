// <auto-generated/>
using Business_Logic.Game.Classes;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;

namespace Wpf.View
{
    /// <summary>
    /// This class handles everything isometric
    /// </summary>
    public class VectorHandler
    {
        private Point I { get; set; }
        private Point J { get; set; }
        private double WindowWidth { get; set; }
        private double WindowHeight { get; set; }
        private double Mapwidth { get; set; }
        private double Mapheight { get; set; }
        private double TileSize { get; set; }
        private float A { get; set; }
        private double OffsetX { get; set; }
        private double OffsetY { get; set; }
        private double Izosize { get; set; }

        /// <summary>
        /// Initializes a new instance of the <see cref="VectorHandler"/> class.
        /// </summary>
        /// <param name="a">Float value for drawing the tiles.</param>
        /// <param name="tilesize">Size of the tile</param>
        /// <param name="windowWidth">Width of the main window</param>
        /// <param name="windowHeight">Height of the main window</param>
        /// <param name="mapwidth">Map width</param>
        /// <param name="mapheight">Map height</param>
        public VectorHandler(float a, double windowWidth, double windowHeight,int mapwidth,int mapheight, double tilesize)
        {
            this.A = a;
            Direction = Direction.Down;
            WindowWidth = windowWidth;
            WindowHeight = windowHeight;
            Mapwidth = mapwidth;
            Mapheight = mapheight;
            TileSize = tilesize;

            ModifiyVectors();

            var v1 = new Point(I.X * TileSize, I.Y * TileSize);
            var v2 = new Point(J.X * TileSize, J.Y * TileSize);
            Izosize = Math.Sqrt(Math.Pow((v1.X - v2.X), 2) + Math.Pow(v1.Y - v2.Y, 2));
        }

        /// <summary>
        /// Gets or sets direction enum property
        /// </summary>
        public Direction Direction { get; set; }

        /// <summary>
        /// Direction change handler
        /// </summary>
        public void ChangeDirection()
        {
            switch (this.Direction)
            {
                case Direction.Up:
                    this.Direction = Direction.Right;
                    break;
                case Direction.Right:
                    this.Direction = Direction.Down;
                    break;
                case Direction.Down:
                    this.Direction = Direction.Left;
                    break;
                case Direction.Left:
                    this.Direction = Direction.Up;
                    break;

            }
            ModifiyVectors();
        }

        /// <summary>
        /// Normalizes a point
        /// </summary>
        /// <param name="a">A point parameter to be normalized</param>
        /// <returns></returns>
        public Point Normalize(Point a)
        {
            float distance = (float)Math.Sqrt(a.X * a.X + a.Y * a.Y);
            return new Point(a.X / distance, a.Y / distance);
        }

        /// <summary>
        /// Calculates the isoposition of a point
        /// </summary>
        /// <param name="point">Point to be calculated</param>
        /// <returns>Returns a point in isometric position.</returns>
        public Point IsoPosition(Point point)
        {
            Point v1 = new Point(point.X * I.X, point.X * I.Y);
            Point v2 = new Point(point.Y * J.X, point.Y * J.Y);
            Point p = new Point((int)(v1.X + v2.X) + OffsetX, (int)(v1.Y + v2.Y) + OffsetY);
            return p;
        }

        /// <summary>
        /// Calculates the normal position of a point
        /// </summary>
        /// <param name="point">Point to be calculated</param>
        /// <returns>Returns a point in normal positon.</returns>
        public Point NormalPosition(Point point)
        {
            Point isowitoutoffset = new Point(point.X - OffsetX, point.Y - OffsetY);
            double n_y = (isowitoutoffset.Y * I.X - isowitoutoffset.X * I.Y) / (J.Y*I.X - J.X * I.Y);
            double n_x = (isowitoutoffset.X - n_y * J.X) / I.X;
            return new Point((int)n_x, (int)n_y);
        }

        /// <summary>
        /// Calculates the isometric width
        /// </summary>
        /// <returns>Returns the width.</returns>
        public int IsoWidth()
        {
            Point v = new Point(I.X - J.X, I.Y - I.Y);
            return (int)Math.Sqrt(v.X * v.X + v.Y * v.Y);
        }

        /// <summary>
        /// Calculates the isometric height
        /// </summary>
        /// <returns>Returns the height.</returns>
        public int IsoHeight()
        {
            Point v = new Point(I.X + J.X, I.Y + I.Y);
            return (int)Math.Sqrt(v.X * v.X + v.Y * v.Y);
        }

        /// <summary>
        /// Calculates the drawing position.
        /// </summary>
        /// <param name="point">Point to be calculated.</param>
        /// <returns>Return the isometric drawing position</returns>
        public Point DrawPosition(Point point)
        {
            switch (this.Direction)
            {
                case Direction.Up:
                    point = new Point(point.X, point.Y - TileSize);
                    break;
                case Direction.Right:
                    point = new Point(point.X + TileSize, point.Y);
                    break;
                case Direction.Down:
                    point = new Point(point.X, point.Y + TileSize);
                    break;
                case Direction.Left:
                    point = new Point(point.X - TileSize, point.Y);
                    break;
                default:
                    break;
            }

            Point p = IsoPosition(point);
            return new Point(p.X, p.Y);
        }

        /// <summary>
        /// Calculates lenght in isometric.
        /// </summary>
        /// <returns>Returns isometric length value.</returns>
        public double IsoLenght()
        {
            return Izosize;
        }

        private void ModifiyVectors()
        {
            switch (this.Direction)
            {
                case Direction.Up:
                    I = Normalize(new Point(A, -1));
                    J = Normalize(new Point(-A, -1));

                    OffsetX = (double)WindowWidth / 2 - ((double)I.X * TileSize * (double)Mapwidth + (double)J.X * TileSize * (double)Mapheight) / 2;
                    OffsetY = (double)WindowHeight / 2 - ((double)I.Y * TileSize * (double)Mapwidth + (double)J.Y * TileSize * (double)Mapheight) / 2;
                    break;
                case Direction.Right:
                    I = Normalize(new Point(A, 1));
                    J = Normalize(new Point(A, -1));

                    OffsetX = (double)WindowWidth / 2 - ((double)I.X * TileSize * (double)Mapwidth + (double)J.X * TileSize * (double)Mapheight) / 2;
                    OffsetY = (double)WindowHeight / 2 - ((double)I.Y * TileSize * (double)Mapwidth + (double)J.Y * TileSize * (double)Mapheight) / 2;
                    break;
                case Direction.Down://def
                    I = Normalize(new Point(-A, 1));
                    J = Normalize(new Point(A, 1));

                    OffsetX = (double)WindowWidth / 2 - ((double)I.X * TileSize * (double)Mapwidth + (double)J.X * TileSize * (double)Mapheight) / 2;
                    OffsetY = (double)WindowHeight / 2 - ((double)I.Y * TileSize * (double)Mapwidth + (double)J.Y * TileSize * (double)Mapheight) / 2;
                    break;
                case Direction.Left:
                    I = Normalize(new Point(-A, -1));
                    J = Normalize(new Point(-A, 1));

                    OffsetX = (double)WindowWidth / 2 - ((double)I.X * TileSize * (double)Mapwidth + (double)J.X * TileSize * (double)Mapheight) / 2;
                    OffsetY = (double)WindowHeight / 2 - ((double)I.Y * TileSize * (double)Mapwidth + (double)J.Y * TileSize * (double)Mapheight) / 2;
                    break;
                default:
                    break;
            }
        }

        internal Rect IsoRectangle(double X, double Y, int Width, int Height)
        {

            double x = X;
            double y = Y;
            int w = Width;
            int h = Height;
            Size size = IsoSize(w, h);
            Point p = IsoPosition(new Point((int)x, (int)y));
            return new Rect(new Point(p.X - size.Width / 2, p.Y - size.Height / 2), size);
        }

        internal Rect IsoRectangle(Rect rect)
        {

            double x = rect.X;
            double y = rect.Y;
            int w = (int)rect.Width;
            int h = (int)rect.Height;
            Size size = IsoSize(w, h);
            Point p = IsoPosition(new Point((int)x, (int)y));
            return new Rect(new Point(p.X - size.Width / 2, p.Y - size.Height / 2), size);
        }

        internal Point IsoPoint(double X, double Y, int Width, int Height)
        {
            double x = X;
            double y = Y;
            Point p = IsoPosition(new Point((int)x, (int)y));
            int w = Width;
            int h = Height;
            Size size = IsoSize(w, h);
            return new Point(p.X - size.Width / 2, p.Y - size.Height / 2);
        }

        private Size IsoSize(int w, int h)
        {
            Point a = new Point(I.X * h, I.Y * h);//h
            Point b = new Point(J.X * w, J.Y * w);//w

            Point v1 = new Point(a.X - b.X, a.Y - b.Y);
            Point v2 = new Point(a.X + b.X, a.Y + b.Y);

            int width = (int)Math.Sqrt(v1.X * v1.X + v1.Y * v1.Y);
            int height = (int)Math.Sqrt(v2.X * v2.X + v2.Y * v2.Y);
            return new Size(width, height);
        }

        internal Size IsoSize(Size size)
        {
            Point a = new Point(I.X * size.Height, I.Y * size.Height);//h
            Point b = new Point(J.X * size.Width, J.Y * size.Width);//w

            Point v1 = new Point(a.X - b.X, a.Y - b.Y);
            Point v2 = new Point(a.X + b.X, a.Y + b.Y);

            int width = (int)Math.Sqrt(v1.X * v1.X + v1.Y * v1.Y);
            int height = (int)Math.Sqrt(v2.X * v2.X + v2.Y * v2.Y);
            return new Size(width, height);
        }
    }
}
